import "https://deno.land/std@0.224.0/dotenv/load.ts";
import { searchGithubRepositories } from "./repository.ts";
import { fetchCves } from "./nvd.ts";
import { getDateHoursBefore, getYesterday } from "./util.ts";
import { DB } from "x/sqlite";

function initDB() {
  const db = new DB("sqlite.db");
  db.execute(`
    CREATE TABLE IF NOT EXISTS vulnerability (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      timestamp TEXT NOT NULL,
      cve TEXT NOT NULL,
      repository_count INTEGER NOT NULL
    );
    `);
  db.query(
    `CREATE INDEX IF NOT EXISTS idx_timestamp ON vulnerability(timestamp);`,
  );
  db.close();
}

async function main() {
  const db = new DB("sqlite.db");

  const now = new Date();
  now.setUTCMinutes(0, 0, 0);

  const oneHourBefore = getDateHoursBefore(1);
  console.log(oneHourBefore, now);

  const cves = await fetchCves(oneHourBefore.toISOString(), now.toISOString());

  for (const defCveItem of cves.vulnerabilities) {
    const cve = defCveItem.cve.id;
    if (cve) {
      console.log(`CVE found: ${cve}`);
      try {
        const repositories = await searchGithubRepositories(cve);
        const repositoryCount = repositories.search.repositoryCount;
        db.query(
          "INSERT INTO vulnerability (timestamp, cve, repository_count) VALUES (?, ?, ?);",
          [
            now,
            cve,
            repositoryCount,
          ],
        );
      } catch (error) {
        console.error(`Error fetching repositories for CVE ${cve}:`, error);
      }
    } else {
      console.log("No CVE identifier found for this advisory.");
    }
  }
}

initDB();
await main();
Deno.exit();
